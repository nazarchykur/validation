package com.example.validationdemo1;

import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;


@Slf4j
@Component
@RequiredArgsConstructor
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {
    private final StudentRepository studentRepository;

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        log.info("checking if email is unique");
        return !studentRepository.findByEmail(value).isPresent();
    }
}

/*
    First you validate object by spring when is create by form, and second time by hibernate before persistence 
    (it's default behavior). hibernate make validation outside Spring context so Autowired doesn't work. 
    That is why you get NullPointerException.
    
    
    if add this property to application.properties file
        spring.jpa.properties.jakarta.persistence.validation.mode=none
    
    
    By default, Bean Validation (and Hibernate Validator) is activated. When an entity is created, updated 
    (and optionally deleted), it is validated before being sent to the database. 
    The database schema generated by Hibernate also reflects the constraints declared on the entity.

    You can fine-tune that if needed:
    
    AUTO: if Bean Validation is present in the classpath, CALLBACK and DDL are activated.
    
    CALLBACK: entities are validated on creation, update and deletion. If no Bean Validation provider is present, 
                an exception is raised at initialization time.
    
    DDL: (not standard, see below) database schemas are entities are validated on creation, update and deletion. 
        If no Bean Validation provider is present, an exception is raised at initialization time.
    
    NONE: Bean Validation is not used at all

 */